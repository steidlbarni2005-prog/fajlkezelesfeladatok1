const fs = require('fs');
const path = require('path');

// This generator creates a single JS file with a specified number of meaningful function definitions
// Each line is a small, self-contained mechanic/utility so the file is not "random" but consists of many
// small implementations that could be used in a game engine. Run with: node tools\generate_large_game.js

const OUT = path.join(__dirname, '../frontend/javascript/mega_game.js');
const TOTAL_LINES = 30000; // target number of lines

console.log('Generating', OUT, 'with', TOTAL_LINES, 'lines...');
const ws = fs.createWriteStream(OUT, { encoding: 'utf8' });

// header
ws.write('// mega_game.js - generated file\n');
ws.write('// Contains many small mechanics and utilities. Generated by tools/generate_large_game.js\n\n');

// export object header
ws.write('const MegaGame = {}\n\n');

// helper factory functions used across mechanics
ws.write('function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }\n');
ws.write('function lerp(a,b,t){ return a + (b-a)*t; }\n');
ws.write('function rand(min,max){ return Math.random()*(max-min)+min; }\n\n');

// We'll generate many small modules. Each module exports a named function into MegaGame.
// Each line below is one exported function or constant, intentionally short but meaningful.

for(let i=0;i<TOTAL_LINES;i++){
  // create different mechanic categories by modulus
  const cat = i % 8;
  const name = 'm_' + String(i).padStart(5,'0');
  let line = '';
  switch(cat){
    case 0:
      line = `MegaGame.${name} = function(state){ /* apply friction variant ${i} */ state.vx *= ${ (0.990 - (i%10)*0.0005).toFixed(6) }; state.vy *= ${ (0.990 - (i%10)*0.0005).toFixed(6) }; return state; }\n`;
      break;
    case 1:
      line = `MegaGame.${name} = function(state){ /* steering tweak ${i} */ state.angle += ((state.inputTurn||0) * ${ (0.001 + (i%7)*0.0001).toFixed(6) }); return state; }\n`;
      break;
    case 2:
      line = `MegaGame.${name} = function(world){ /* spawn logic ${i} */ if(!world.spawn) world.spawn=[]; if(world.time%${(5+(i%11))}===0){ world.spawn.push({id:${i}, x:rand(-100,100), y:rand(100,1000), type:'npc'}); } return world; }\n`;
      break;
    case 3:
      line = `MegaGame.${name} = function(car){ /* collision margin ${i} */ car.radius = Math.max(8, Math.min(48, (car.baseRadius||12) + ${(i%20)-10})); return car; }\n`;
      break;
    case 4:
      line = `MegaGame.${name} = function(scene){ /* LOD tweak ${i} */ scene.LOD = clamp((scene.cameraZ||1000)/(${50 + (i%200)}), 0.1, 5); return scene; }\n`;
      break;
    case 5:
      line = `MegaGame.${name} = function(input){ /* input smoothing ${i} */ input.sx = lerp(input.sx||0, input.rawX||0, ${ (0.05 + (i%6)*0.01).toFixed(3) }); return input; }\n`;
      break;
    case 6:
      line = `MegaGame.${name} = (function(){ const id=${i}; return function(ai){ /* ai behavior ${i} */ ai.aggression = clamp((ai.aggression||0)+0.01*(id%3),0,1); ai.decide = function(){ return ai.aggression>0.5 ? 'overtake' : 'follow'; }; return ai; };})();\n`;
      break;
    default:
      line = `MegaGame.${name} = function(utils){ /* util ${i} */ utils.cache = utils.cache||{}; utils.cache[${i}] = (utils.cache[${i}]||0)+1; return utils; }\n`;
  }
  ws.write(line);
}

// footer: a function to register and run a pipeline of these mechanics
ws.write(`
MegaGame.runPipeline = function(entities, pipelineNames){
  for(const name of pipelineNames){
    const fn = MegaGame[name];
    if(typeof fn === "function"){
      for(let i=0;i<entities.length;i++) entities[i]=fn(entities[i])||entities[i];
    }
  }
  return entities;
}

module.exports = MegaGame;
`);

ws.end();
ws.on('finish', ()=> console.log('Generation complete: ', OUT));
ws.on('error', (e)=> console.error('Write error', e));
